<?xml version="1.0" encoding="windows-1251" ?>

<!DOCTYPE page [
<!ENTITY nbsp "&#160;">
<!ENTITY пробел "&#160;">
<!ENTITY shy "&#173;">
<!ENTITY перенос "&#173;">
]>

<?xml:stylesheet type="text/xsl" href="../common/layout.xsl" ?>

<Урок xmlns="x-schema:Schema.xml" название="Анализ функций РНР для работы с ODBC-функций" 
предыдущий="section04.xml" следующий="section06.xml">

<h1 style="color:maroon">Анализ функций РНР для работы с ODBC-функций</h1>

<h3>Открытие и закрытие базы данных</h3>

	<p><b>odbc_connect </b>- Соединяет с источником данных </p>
	<pre>int odbc_connect (string dsn, string user, string password); </pre>
	<p>Возвращает идентификатор ODBC-соединения или 0 ( false ) при ошибке. Идентификатор соединения, возвращаемый этой функцией, запрашивается другими ODBC функциями. Вы можете иметь несколько соединений открытых одновременно. </p>

	<p><b>odbc_pconnect </b>- Открывает постоянное соединение с базой данных </p>
	<pre>int odbc_pconnect (string dsn, string user, string password); </pre>
	<p>Возвращает идентификатор ODBC соединения или 0 ( false ) при ошибке. Эта функция очень похожа на	<i>odbc_connect() </i>, кроме того, что соединение в действительности не закрывается после завершения скрипта. Будующие запросы на соединение с той же комбинацией параметров <i>dsn , user , password</i> (через odbc_connect() и odbc_pconnect() ) могут повторно использовать постоянное соединение. Постоянные соединения не действуют, если PHP используется как CGI программа.</p>

	<p><b>odbc_close </b>- Закрывает ODBC-соединение </p>
	<pre>void odbc_close (int connection_id); </pre>
	<p><i>odbc_close()</i> закрывает соединение с сервером баз данных, связанное с указанным 	идентификатором соединения. Эта функция выдаст ошибку, если у этого соединения есть запущенные транзакции. Соединение останется открытым в этом случае.</p>

	<p><b>odbc_close_all </b>- Закрывает все ODBC-соединения </p>
	<pre>void odbc_close_all (void); </pre>
	<p><i>odbc_close_all()</i> закрывает все соединения с сервером(серверами) баз данных. Эта функция выдаст ошибку, если у этих соединений есть незавершенные транзакции. В этом случае соединения останутся открытыми.</p>

<h3>Фнкции, осуществляющие запросы к базе данных</h3>

	<p><b>odbc_exec </b>- Подготовка и запуск SQL-запроса </p>
	<pre>int odbc_exec (int connection_id, string query_string);</pre> 
	<p>Возвращает false при ошибке. Возвращает ODBC-идентификатор результата, если SQL команда была запущена успешно. </p>
	<p><i>odbc_exec()</i> посылает SQL-запрос серверу баз данных, определенному параметром connection_id . Этот параметр должен быть правильным идентификатором, возвращенным функцией odbc_connect(). </p>

	<p><b>odbc_do </b>- совпадает с <i>odbc_exec()</i> </p>
	<pre>string odbc_do (int conn_id, string query); </pre>
	<p><i>odbc_do </i>запускает запрос на указанном соединении</p>

	<p><b>odbc_prepare </b>- Подготавливает запрос для запуска </p>
	<pre>int odbc_prepare (int connection_id, string query_string); </pre>
	<p>Возвращает false при ошибке. Возвращает ODBC-идентификатор результата, если SQL команда была подготовлена успешно. Идентификатор результата может быть использован для последеющего запуска запроса с помощью <i>odbc_execute()</i> .</p>

	<p><b>odbc_execute </b>- запускает подготовленный SQL-запрос </p>
	<pre>int odbc_execute (int result_id, array [ parameters_array ]); </pre>
	<p>Запускает SQL-запрос, подготовленный функцией <i>odbc_prepare()</i> . Возвращает true при успешном запуске, false о обратном случае. Массив arameters_array необходим только если вы действительно имеете параметры в вашем SQL-запросе.</p>

<h3>Функции для обработки результатов выполненного запроса</h3>

	<p><b>odbc_cursor </b>- Получает имя курсора </p>
	<pre>string odbc_cursor (int result_id); </pre>
	<p><i>odbc_cursor </i>возвращает имя курсора для указанного result_id.</p>

	<p><b>odbc_fetch_into </b>- Извлекает одну строку результата в массив </p>
	<pre>int odbc_fetch_into (int result_id, int [ rownumber ], array result_array); </pre>
	<p>Возвращает число столбцов в результате; false при ошибке. result_array может быть любого типа, так как он будет конвертирован в тип массив. Массив будет содержать значения полей начиная с индекса 0 массива.</p>

	<p><b>odbc_fetch_row </b>- Извлекает строку </p>
	<pre>int odbc_fetch_row (int result_id, int [ row_number ]); </pre>
	<p>Если <i>odbc_fetch_row()</i> прошла успешно (строка существовала), то будет возвращено true. Если больше строк нет, то будет возвращено false. </p>
	<p><i>odbc_fetch_row()</i> извлекает строку из данных, возвращенных функцией <i>odbc_do() / odbc_exec()</i> . После вызова <i>odbc_fetch_row()</i> , доступ к полям той строки может быть осуществлен с помощью функции <i>odbc_result()</i> . </p>
	<p>Если параметр <i>row_number</i> не указан, то <i>odbc_fetch_row()</i> бедет пытаться извлечь следующую строку в результирующем наборе. Вызов функции <i>odbc_fetch_row()</i> можно осуществлять как с, так и без параметра <i>row_number</i> . </p>
	<p>Для использования результата более одного раза, вы можете вызвать <i>odbc_fetch_row()</i> с <i>row_number </i>1, и затем продолжить выполнять <i>odbc_fetch_row()</i> без row_number для просмотра результата. Если драйвер не поддерживает извлечение строк по номеру, то параметр <i>row_number</i> игонорируется.</p>

	<p><b>odbc_field_name </b>- Возвращает имя столбца </p>
	<pre>string odbc_fieldname (int result_id, int field_number); </pre>
	<p><i>odbc_field_name() </i>возвращает имя поля в соответствии с указанным номером столбца в указанном ODBC-идентификаторе результата. Номера полей начинаются с 1. false возвращается при ошибке.</p>

	<p><b>odbc_field_type </b>- тип данных поля </p>
	<pre>string odbc_field_type (int result_id, int field_number); </pre>
	<p><i>odbc_field_type()</i> возвращает SQL тип поля в соответствии с номером в указанном ODBC-идентификаторе результата. Номера полей начинаются с 1.</p>

	<p><b>odbc_field_len </b>- возвращает длину поля </p>
	<pre>string odbc_field_type (int result_id, int field_number); </pre>
	<p><i>odbc_field_type() </i>возвращает длину поля в соответствии с номером в указанном ODBC-идентификаторе результата. Номера строк начинаются с 1.</p>

	<p><b>odbc_longreadlen </b>- обработка полей типа LONG </p>
	<pre>int odbc_longreadlen (int result_id, int length);</pre> 
	<p>(Обрабатываемые ODBC SQL типы : LONG, LONGVARBINARY) Число байтов, возвращенных PHP, контролируется длиной параметра <i>length</i>. Если она установлена в 0, то данные типа Long передаются клиенту. </p>

	<p><b>odbc_num_fields </b>- число столбцов в результате </p>
	<pre>int odbc_num_fields (int result_id); </pre>
	<p><i>odbc_num_fields() </i>возвращает число полей (столбцов) в результате ODBC. Эта функция вернет -1 при ошибке. Аргумент является правильным результирующим идентификатором, возвращенным <i>odbc_exec()</i> .</p>

	<p><i>odbc_num_rows </i>- Число строк в результате </p>
	<pre>int odbc_num_rows (int result_id); </pre>
	<p><i>odbc_num_rows() </i>возвращает число строк в ODBC результате. Эта функция вернет -1 при ошибке. Для команд INSERT, UPDATE и DELETE <i>odbc_num_rows()</i> вернет число обработанных строк. Для случая SELECT это может быть число доступных строк. </p>
	<p>Использование <i>odbc_num_rows()</i> для определения числа строк, доступных после SELECT вернет 	-1 у многих драйверов.</p>

	<p><b>odbc_result </b>- получает результирующие данные </p>
	<pre>string odbc_result (int result_id, mixed field); </pre>
	<p>Возвращает содержимое поля. Поле может быть целым числом, содержащим номер столбца необходимого вам поля, или оно может быть строкой, содержащей имя поля. Например: </p>
    <pre> $item_3 = odbc_result($Query_ID, 3 );
     $item_val = odbc_result($Query_ID, "val");</pre>
	<p>Первый вызов <i>odbc_result()</i> вернет значение третьего поля в текущей записи результата запроса. Второй вызов функции <i>odbc_result()</i> возвратит значение поля, имя которого "val" в текущей записи результата запроса. Ошибка возникнет, если параметр номера столбца для поля меньше, чем один или более номеров столбцов (или полей) в текущей записи. Так же ошибка возникнет, если запрашивается поле с именем, не совпадающем с именами полей в запрашиваемой таблице (таблицах). Номера полей начинаются с 1.</p>

	<p><b>odbc_result_all </b>- Выдача результата в виде HTML таблицы </p>
	<pre>int odbc_result_all (int result_id, string [ format ]); </pre>
	<p>Возвращает число строк в результате или false при ошибке. 
<i>odbc_result_all() </i>выдает все строки из идентификатора результата, полученного от odbc_exec(). Результат выдается в формате HTML таблицы. С дополнительным строковым аргументом format , может быть осуществлено дополнительное форматирование таблицы.</p>

	<p><b>odbc_free_result </b>- освобождает ресурсы, связанные с результатом </p>
	<pre>int odbc_free_result (int result_id); </pre>
	<p>Всегда возвращает true. </p>
	<p><i>odbc_free_result()</i> необходимо вызывать только если вы беспокоитесь об использовании большого количества памяти во время запуска вашего скрипта. Вся память результата будет автоматически освобождена при завершении скрипта. Но, если вы уверены, что больше нигде в скрипте не будете использовать данные результата, то вы можете вызвать <i>odbc_free_result() </i>, и память, связанная с параметром <i>result_id</i> будет освобождена. </p>


<h3>Функции для работы с транзакциями</h3>

	<p><b>odbc_autocommit</b> - Переключает режим автофиксирования (auto-commit) </p>
	<pre>int odbc_autocommit (int connection_id, int [ OnOff ]); </pre>
	<p>Без параметра OnOff эта функция возвращает статус автофиксирования для connection_id . True возвращается, если автофиксирование включено, false если оно выключено или если произошли ошибки. </p>
	<p>Если параметр OnOff установлен в true, то автофиксирование включено, если параметр установлен в ложь, то автофиксирование отключено. True возвращается при успешном завершении, false - при ошибке. </p>
	<p>По умолчанию автофиксирование включено для соединения. Отключение автофиксирования эквивалентно началу транзакции. </p>

	<p><b>odbc_commit </b>- Фиксирует транзакцию ODBC </p>
	<pre>int odbc_commit (int connection_id); </pre>
	<p>Возвращает: true при успехе, false при ошибке. Все незаконченные транзакции на connection_id фиксируются.</p>

	<p><b>odbc_rollback </b>- Откат транзакции </p>
	<pre>int odbc_rollback (int connection_id); </pre>
	<p>Откатавает все незаконченные запросы на <i>connection_id </i>. Возвращает true при успехе, false при ошибке.</p>


</Урок>