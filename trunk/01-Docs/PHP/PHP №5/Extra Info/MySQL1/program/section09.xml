<?xml version="1.0" encoding="windows-1251" ?>

<!DOCTYPE page [
<!ENTITY nbsp "&#160;">
<!ENTITY пробел "&#160;">
<!ENTITY shy "&#173;">
<!ENTITY перенос "&#173;">
]>

<?xml:stylesheet type="text/xsl" href="../common/layout.xsl" ?>

<Урок xmlns="x-schema:Schema.xml" название="Стандартные блоки диалога" предыдущий="section08.xml" следующий="section10.xml">

<h2><font color="maroon">Стандартные блоки диалога.<br>Класс CFileDialog (файловый диалог)</br></font></h2>
<p>
Генеалогия
</p>
<image src="3.png"></image>
<p>
Стандартные блоки диалога применяются для выполнения каких-либо стандартных
действий, как-то: открытие файлов, выбор шрифта, выбор цвета и т. д. В текущей
версии библиотеки MFC существует поддержка следующих классов: CFileDialog,
CFindReplaceDialog, CColorDialog, CPrintDialog и CPageSetupDialog. В данном разделе
будет рассмотрен класс CFileDialog, отвечающий за создание и работоспособность
двух блоков диалога: один позволяет выбрать файл для его последующего открытия,
а другой предназначен для выбора расположения и имени файла при его сохранении.
</p>
<pre>
Кстати, на самом деле этот один и тот же диалог, различия только внешние.
</pre>
<p>
Начинающие программисты часто думают, что эти диалоги самостоятельно открывают
и сохраняют требуемые файлы, но на самом деле это всего лишь удобный способ
для выбора места хранения и имени файла. Все операции по физическому открытию
файлов, а также операции по чтению и записи в них осуществляются программистом.
</p>
<p>
Итак, что же представляет из себя файловый диалог... (см. рисунки)
</p>
<p>
Диалог для открытия файлов
</p>
<image src="4.png"></image>
<p>
Диалог для записи файлов
</p>
<image src="5.png"></image>
<p>
Без сомнения, они вам знакомы и, будем надеяться, вопросы по поводу что и где
нажимать возникать не должны. Теперь перейдем к вопросам программирования.
</p>
<p><strong>
Инициализация
</strong></p>
<pre>
// Класс представлен одним конструктором
CFileDialog( BOOL bOpenFileDialog, LPCTSTR lpszDefExt = NULL,
             LPCTSTR lpszFileName = NULL,
             DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
             LPCTSTR lpszFilter = NULL, CWnd* pParentWnd = NULL );
// Параметры:

// если параметр bOpenFileDialog истина, то создается Open Dialog,
// иначе - Save Dialog.

// lpszDefExt - строка или указатель на буфер, который содержит
// расширение имени файла, используемое по умолчанию. Эта строка 
// добавляется к имени выбранного файла, если расширение не было
// указано пользователем. Она может иметь произвольную длину, но не
// должна содержать точек.
</pre>
<pre>Предупреждение:
если вы вводите после имени файла "левое" расширение, то есть расширение,
которое не зарегистрировано в операционной системе, и у вас установлено
расширение по умолчанию, то оно также добавится к вашему файлу.
Например, по умолчанию txt, а вы вводите a.bbb - получится a.bbb.txt
</pre>
<pre>
// lpszFileName - строка или указатель на буфер, который содержит
// имя файла, используемое по умолчанию.

// dwFlags - комбинация из одного или нескольких флагов, объединенных
// с помощью операции побитового "или" (|), позволяющих настроить
// внешний вид диалога.
// Флаги:
// OFN_ALLOWMULTISELECT - разрешает выбор нескольких файлов одновременно.

// OFN_CREATEPROMPT - если пользователь определяет несуществующий файл,
// то выводится блок диалога, в котором предгается создать файл.

// OFN_EXPLORER - указывает, что при создании блоков диалога используется
// новый стиль EXPLORER. Этот стиль используется независимо от того
// установлен он или нет.

// OFN_EXTENSIONDIFFERENT - устанавливается после возвращения из функции
// и указывает, что расширение выбранного файла отличается от того,
// которое было ранее определено в поле lpszDefExt. Этот флаг не
// устанавливается, если в поле lpszDefExt был установлен NULL или файл
// не имеет расширения.

// OFN_FILEMUSTEXIST - определяет, что в поле FileName пользователь
// может вводить только имена существующих файлов. В противном случае
// на экран выводится предупреждающее сообщение. Если этот флаг
// определен, то автоматически устанавливается флаг OFN_PATHMUSTEXIST.

// OFN_HIDEREADONLY - предписывает убрать из блока диалога флажок
// только чтение (Read Only).

// OFN_NOCHANGEDIR - устанавливает первоначальный текущий каталог, если
// пользователь изменил его при поиске файлов.

// OFN_NODEREFERENCELINKS - предписывает блоку диалога возвратить имя и
// путь выбранного сокращения (shortcut) - файла с расширением LNK.
// В противном случае блок диалога возвращает путь и имя файла, на 
// который ссылается сокращатель.

// OFN_NONETWORKBUTTON - скрывает и блокирует кнопку Network (сеть).

// OFN_NOREADONLYRETURN - определяет, что выбранный файл не имеет 
// атрибута "только чтение" и не располагается в защищенном от записи
// каталоге.

// OFN_NOTESTFILECREATE - определяет, что файл не создается перед
// закрытием блока диалога, а также отсутствие проверки на защиту от
// записи, переполнение диска и сетевую защиту.

// OFN_NOVALIDATE - определяет, что стандартные блоки диалога допускают
// наличие неразрешенных символов в именах возвращаемых файлов.

// OFN_OVERWRITEPROMPT - предписывает блоку диалога Save As (сохранение)
// выводить окно запроса на перезапись, если выбранный файл уже
// существует.

// OFN_PATHMUSTEXIST - определяет, что пользователь может использовать
// только имеющиеся пути и имена файлов. В противном случае на экран
// выводится предупреждающее сообщение.

// OFN_READONLY - при отображении блока диалога флажок Read Only (только
// чтение) будет установлен, а при закрытии блока диалога указывает
// состояние флажка.

// OFN_SHOWHELP - предписывает блоку диалога отображать кнопку Help (?).

// lpszFilter - строка или указатель на буфер, содержащий одну или
// несколько пар текстовых строк, задающих фильтры для выбора имен файлов.
// Первая строка в каждой паре описывает название фильтра (например, 
// "Исполняемые файлы"), а вторая - образец фильтра (например,
// "*.exe;*.com;*.bat"). Если в единственной строке фильтра необходимо
// указать несколько образцов, то они должны отделяться друг от друга
// символом "|". Последняя строка должна заканчиваться двумя символами
// "|", за которыми должен следовать нулевой символ. Порядок следования
// пар строк в буфере (в строке) определяет порядок следования фильтров.
// Если этот параметр равен NULL, то в блоке диалога не определен никакой
// фильтр.

// Дескриптор окна, владеющего блоком диалога или NULL.
</pre>
<p>
Кроме того, в классе представлен объект Windows-структуры OPENFILENAME
m_ofn. Эта структура инициализирует внешний вид File Open и File Save As
диалогов после их создания, но перед отображением. Многие поля этой структуры
уже рассмотрены при описании конструктора класса. Ниже приведены некоторые из
тех полей, которых нельзя "достать" из конструктора.
</p>
<pre>
LPCTSTR lpstrInitialDir;
// указывает на строку, которая определяет начальный каталог. Чтобы начать
// работу в текущем каталоге в это поле нужно записать NULL.

LPCTSTR lpstrTitle;
// указывает на строку, которая определяет заголовок блока диалога. Если
// это поле содержит NULL, то будут использоваться стандартные заголовки
// Open (открытие файла) и Save As (сохранение).
</pre>
<p>
Пример использования:
</p>
<pre>
         // ...
         CFileDialog fOpen(true);
         fOpen.m_ofn.lpstrTitle = "Откройте меня !!!";
         fOpen.DoModal();
         // ...
</pre>
<p><strong>
Операции
</strong></p>
<pre>
virtual int DoModal( );
// Отображает блок диалога на экране. Возвращает, в зависимости от выбора
// пользователя, IDOK или IDCANCEL.

CString GetPathName( ) const;
// Возвращает полный путь к файлу (например, C:\Windows\notepad.exe).

CString GetFileName( ) const;
// Возвращает имя файла (например, notepad.exe).

CString GetFileExt( ) const;
// Возвращает расширение файла (например, exe).

CString GetFileTitle( ) const;
// Возвращает имя файла без расширения (например, notepad).

CString GetNextPathName( POSITION&amp; pos ) const;
// Возвращает полный путь к файлу.
// pos - ссылка на значение типа POSITION, возвращаемое предыдущим вызовом
// функции GetNextPathName или функции GetStartPosition, или NULL, если
// достигнут конец списка.
// Функция используется для получения следующего пути к файлу из списка
// выбранных одновременно файлов (если перед отображением блока диалога
// был установлен флаг OFN_ALLOWMULTISELECT).

BOOL GetReadOnlyPref( ) const;
// Возвращает истину, если флажок Read Only (только чтение) на блоке
// диалога был установлен (поставлена галочка), иначе - ложь.

POSITION GetStartPosition( ) const;
// Возвращает значение типа POSITION, используемое для итерации, или
// NULL в случае, если список пуст.
// Функция используется для получения позиции первого пути к файлу из
// списка выбранных одновременно файлов (если перед отображением блока
// диалога был установлен флаг OFN_ALLOWMULTISELECT).
</pre>
<pre>Информация:
POSITION - тип данных, который используется для хранения позиций элементов
в коллекциях (массивы, простые и ассоциативные списки, которые могут
хранить различные объекты и предопределенные типы).
</pre>
<pre><b>Примечание:
за более полной информацией обращайтесь в MSDN.
</b></pre>
</Урок>